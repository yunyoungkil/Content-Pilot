/*! Quill Image Resize Module (Quill 2.x safe, window.ImageResize only) | MIT License */
(function () {
  function clamp(n, min, max) {
    return Math.min(max, Math.max(min, n));
  }
  function px(n) {
    return (n | 0) + "px";
  }
  class ImageResize {
    constructor(quill, options) {
      this.quill = quill;
      this.options = options || {};
      this.img = null;
      this.box = null;
      this.dragging = false;
      this.dragStart = null;
      const root = this.quill.root;
      root.addEventListener("click", this.onClick);
      root.addEventListener("mousedown", this.onDown);
      root.addEventListener("mouseup", this.onUp);
      root.addEventListener("mousemove", this.onMove);
      root.addEventListener("mouseleave", this.hide);
      root.addEventListener("keyup", this.hide);
      root.addEventListener("scroll", this.hide);
      root.addEventListener("blur", this.hide);
      // 빈 블록 자동 제거: text-change 이벤트에서 DOM 기반으로 제거
      quill.on &&
        quill.on("text-change", () => {
          this.removeEmptyParagraphs();
        });
    }
    // DOM 기반 빈 문단 제거
    removeEmptyParagraphs = () => {
      const root = this.quill?.root;
      if (!root) return;
      const paras = Array.from(root.querySelectorAll("p"));
      paras.forEach((p) => {
        // 정확히 <p><br></p> 이거나 공백만 있는 경우 제거
        const html = p.innerHTML.trim();
        const text = p.textContent?.trim() || "";
        if (
          (html === "<br>" || text === "") &&
          p.querySelector("img") == null
        ) {
          // 단, 에디터에 유일한 블록으로 남는 경우는 유지
          if (root.children.length > 1) {
            p.remove();
          }
        }
      });
    };
    onClick = (e) => {
      if (e.target && e.target.tagName === "IMG") {
        this.img = e.target;
        this.show();
      } else {
        this.hide();
      }
    };
    onDown = (e) => {
      if (this.img && e.target === this.img) {
        // Quill의 기본 선택/줄삽입을 막아 불필요한 <p><br></p> 생성 방지
        e.preventDefault();
        e.stopPropagation();
        this.dragging = true;
        this.dragStart = {
          x: e.clientX,
          y: e.clientY,
          width: this.img.width,
          height: this.img.height,
        };
      }
    };
    onUp = (e) => {
      if (this.dragging) {
        // Quill 기본 동작 억제
        e && e.preventDefault && e.preventDefault();
        e && e.stopPropagation && e.stopPropagation();
        this.dragging = false;
        // 리사이즈 종료 시 자동 저장 메시지 emit
        if (window.parent && this.img) {
          // 불필요한 빈 문단 DOM 기반 정리 후 저장
          this.removeEmptyParagraphs();
          const html = this.quill.root.innerHTML;
          window.parent.postMessage(
            { action: "cp_save_draft", content: html },
            "*"
          );
        }
      }
    };
    onMove = (e) => {
      if (this.dragging) {
        // 기본 동작 억제 (텍스트 선택 등)
        e.preventDefault();
        e.stopPropagation();
        const dx = e.clientX - this.dragStart.x;
        let newW = clamp(this.dragStart.width + dx, 30, 2000);
        this.img.setAttribute("width", newW);
        this.img.style.width = newW + "px";
        this.show();
      }
    };
    show = () => {
      if (!this.img) return;
      this.hide();
      // 오버레이 div 생성 (완전히 인라인 스타일로만 처리)
      const doc = this.quill.root.ownerDocument || document;
      const box = doc.createElement("div");

      // 이미지의 화면 좌표를 그대로 사용 (fixed position)
      const rect = this.img.getBoundingClientRect();

      // 모든 스타일을 인라인으로 강제 적용
      box.style.cssText = `
        position: fixed !important;
        left: ${rect.left}px !important;
        top: ${rect.top}px !important;
        width: ${rect.width}px !important;
        height: ${rect.height}px !important;
        border: 2px solid #4285f4 !important;
        border-radius: 8px !important;
        box-shadow: 0 0 0 3px rgba(66,133,244,0.15), 0 2px 8px rgba(66,133,244,0.10) !important;
        background: rgba(255,255,255,0.01) !important;
        pointer-events: none !important;
        z-index: 999999 !important;
        box-sizing: border-box !important;
      `;

      // body에 직접 append (position fixed는 body 기준으로 동작)
      (doc.body || doc.getElementsByTagName("body")[0]).appendChild(box);
      this.box = box;
    };
    hide = () => {
      if (this.box && this.box.parentNode)
        this.box.parentNode.removeChild(this.box);
      this.box = null;
    };
  }
  window.ImageResize = ImageResize;
})();
